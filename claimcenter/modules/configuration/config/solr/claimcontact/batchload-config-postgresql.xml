<?xml version="1.0"?>

<document
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="solr-batchload-config.xsd"
  version="1">

  <param name="appPrefix" value="cc"/>

  <!--
  If the debug param is set to true, then all intermediate files in the WorkDir are not deleted.
  See the log4j2.xml file to modify the general logging level.
  -->
  <param name="debug" value="false"/>

  <param name="solrRoot" value="/opt/gwsolr"/>

  <param name="documentRoot" value="${osenv.SOLR_HOME}/claimcontact_active" env="cloud-dev"/>
  <param name="documentRoot" value="${solrRoot}/cc/solr/claimcontact_active"/>

  <param name="collectionConfig" value="${osenv.COLLECTION_CONFIG}" env="cloud-dev"/>
  <param name="collectionConfig" value="${documentRoot}/conf"/>

  <!--
  When a newline is detected in an entity or mvfield record, this option controls whether the associated
  key is masked or not.  Disable masking if the key does not contain PII data and knowing the value would
  be helpful for correcting the data.  Default value is true (masking enabled).
  -->
  <param name="rowIdentifierMaskingEnabled" value="true"/>

  <!--
  If the Solr Batch Loader is run from within the Guidewire app (ClaimCenter,
  PolicyCenter, etc.), the location of the solrServerConfigFile
  param is taken from the Guidewire app, not from the parameter below and the
  value for the absolutePathToWorkDir param is determined from the contents of
  that file, not from the parameter below.
  -->
  <param name="solrServerConfigFile" value="${collectionConfig}/solrserver-config.xml"/>
  <param name="absolutePathToWorkDir" value="${documentRoot}/workDir"/>

  <!--
  The parameter absolutePathToSortExe specifies what sort facility the
  SolrBatchLoader should use. You can either specify the literal "internalSort"
  or an absolute path to an external sort utility:

  1.) internalSort : this will cause the SolrBatchLoader to use an in-memory
  Java-based sort facility. This option should be used only in development/demo
  mode where the number of entity rows to be fetched by the batch loader is less
  than 10000 (if you exceed 10000 rows, the batch loader will throw an exception).

  2.) <abolute_path_to_an_external_sort_utility> : this will cause the
  SolrBatchLoader to use an external, high-performance sort utility. This option
  should be used in production mode. On Unix/Linux the sort utility is typically
  located at /usr/bin/sort. On Windows, Guidewire only supports the Cygwin sort
  utility (you must download and install Cygwin). Typically, the Cygwin sort
  utility is located at c:\cygwin\bin\sort.exe. Be sure to include the .exe
  extension in the value of absolutePathToSortExe if you are specifying the
  location of the sort utility on Windows.
  -->
  <param name="absolutePathToSortExe" value="${osenv.BATCHLOAD_SORT_PATH}" env="cloud-dev"/>
  <param name="absolutePathToSortExe" value="internalSort"/>
  <param name="sortType" value="numeric"/>

  <!--
  The four parameters, sortFieldArgStyle, entitySortMemSize, mvFieldSortMemSize, and absolutePathToSortTmpDir, are
  enabled only if you are using an external sort utility.
  -->
  <param name="sortFieldArgStyle" value="posix"/>

  <param name="entitySortMemSize" value="${osenv.BATCHLOAD_ENTITY_SORT_MEM}" env="cloud-dev"/>
  <param name="entitySortMemSize" value="2G"/>

  <param name="mvFieldSortMemSize" value="${osenv.BATCHLOAD_MVFIELD_SORT_MEM}" env="cloud-dev"/>
  <param name="mvFieldSortMemSize" value="1G"/>

  <param name="absolutePathToSortTmpDir" value="${osenv.BATCHLOAD_TMP_DIR}/sortTmpDir" env="cloud-dev"/>
  <param name="absolutePathToSortTmpDir" value="${documentRoot}/workDir/sortTmpDir"/>

  <!--
  The list of transforms (as defined in the <transformer> elements; see below)
  gets applied to the stream of documents coming out of the last joiner. The
  application of these transforms to any one document is independent of their application
  to all other documents. So, the stream of documents can be partitioned and the list of
  transforms can be applied in parallel to each partition. The following parameter
  specifies how many partitions and separate threads should be created to do the
  transforming. In order to run multiple transformer threads, ALL TRANSFORMER CLASSES
  MUST BE THREAD SAFE. In particular, since the input line and the transformed
  output line are in XML and XML parsing and formatting are not thread safe, you must
  allocate separate parsers and formatters for each instance of a transformer. In other
  words, your transformer should not share static resources unless you are sure they
  are read-only/immutable. Serializing access to shared static resources will just degrade
  performance. The maximum number of transform threads is 10.
  -->
  <param name="numTransformThreads" value="3"/>

  <!--
  When disableSolrDataImport is false (the default), Solr is contacted automatically to process the
  generated XML document and load it as the new index.
  
  Set this property to true if you wish to only generate the bulkload file from SQL but are not yet
  ready to load it into Solr.  Use the DataImport page for the associated Solr Core, viewable
  in the Solr Admin UI at http://SOLR_HOST:8983/solr/#/ to have Solr load the file when ready.
  
  IMPORTANT: To avoid errors in the index, make sure the corresponding Solr message destination
  remains suspended until this file has been loaded (or discarded).  Otherwise you may have to
  regenerate the file to ensure the resulting index is correct and complete.
  -->
  <param name="disableSolrDataImport" value="${osenv.BATCHLOAD_CREATE_BULKLOAD_FILE_ONLY}" env="cloud-dev"/>
  <param name="disableSolrDataImport" value="false"/>

  <!--
  If the Solr Batch Loader is run from within the Guidewire app (ClaimCenter,
  PolicyCenter, etc.), the settings in the following <dataSource> element are
  overridden by the settings in the <database> element in config.xml or
  config-override.xml.
  -->
  <!-- Update URL to include database server details and credentials or appropriate substitution fields -->
  <dataSource name="ds_postgresql" driver="org.postgresql.Driver" url="${osenv.DATABASE_JDBC_URL}" env="cloud-dev"/>
  <dataSource name="ds_postgresql" driver="org.postgresql.Driver" url="jdbc:postgresql://HOST:PORT/DATABASENAME?user=USER&amp;password=PASSWORD"/>

  <!-- Entity and mvField queries -->
  
  <entity
    name="claimcontact"
    query="
      select
        cc.id as claimContactId,
        cl.id as claimId,
        'claimPublicID=' || cl.publicid || '&amp;contactPublicID=' || co.publicid as urn,
        cl.claimnumber as claimNumber,
        pol.policynumber as policyNumber,
        cast(cl.lossdate as Timestamp) as lossDate,
        cast(cl.reporteddate as Timestamp) as reportedDate,
        cast(cl.closedate as Timestamp) as closeDate,
        cast(cl.createtime as Timestamp) as createTime,
        co.firstname as firstName,
        co.lastname as lastName,
        (case when co.firstname is not null then co.firstname else '' end) ||
        (case when co.lastname is not null then ' ' || co.lastname else '' end) ||
        (case when co.name is not null then co.name else '' end) as fullname,
        co.name as businessName,
        (case when a.addressLine1 is not null then a.addressLine1 else '' end) ||
        (case when a.addressLine2 is not null then ', ' || a.addressLine2 else '' end) ||
        (case when a.addressLine3 is not null then ', ' || a.addressLine3 else '' end) as address,
        a.city as city,
        st.typecode as state,
        a.postalcode as postalCode,
        co.licensenumber as licenseNumber
      from
        cc_contact co
        inner join cc_claimcontact cc on cc.contactid = co.id
        inner join cc_claim cl on cc.claimid = cl.id
        left outer join cc_address a on co.primaryaddressid = a.id
        left outer join cctl_state st on st.id = a.state
        inner join cctl_contact cot on cot.id = co.subtype
        inner join cc_policy pol on cl.policyid = pol.id"
    keys="claimContactId,claimId"
  />

  <mvField
    name="phone"
    query="
        select
          cc.id as claimContactId,
          co.homephone as phone
        from
          cc_contact co,
          cc_claimcontact cc
        where
          co.homephone is not null and
          cc.contactid = co.id
      union
        select
          cc.id as claimContactId,
          co.cellphone as phone
        from
          cc_contact co,
          cc_claimcontact cc
        where
          co.cellphone is not null and
          cc.contactid = co.id
      union
        select
          cc.id as claimContactId,
          co.workphone as phone
        from
          cc_contact co,
          cc_claimcontact cc
        where
          co.workphone is not null and
          cc.contactid = co.id"
    entityKey="claimContactId"
    keys="claimContactId"
  />

  <mvField
    name="role"
    query="select ccr.claimcontactid as claimContactId, r.name as role from cctl_contactrole r, cc_claimcontactrole ccr where r.id = ccr.role"
    entityKey="claimContactId"
    keys="claimContactId"
  />

  <mvField
    name="userId"
    query="select ca.claimid as claimId, ca.userid as userId from cc_claimaccess ca where ca.permission = 10002 and ca.userid is not null"
    entityKey="claimId"
    keys="claimId"
  />

  <mvField
    name="groupId"
    query="select ca.claimid as claimId, ca.groupid as groupId from cc_claimaccess ca where ca.permission = 10002 and ca.groupid is not null"
    entityKey="claimId"
    keys="claimId"
  />

  <mvField
    name="securityZoneId"
    query="select ca.claimid as claimId, ca.securityzoneid as securityZoneId from cc_claimaccess ca where ca.permission = 10002 and ca.securityzoneid is not null"
    entityKey="claimId"
    keys="claimId"
  />

  <!-- "anyone" mvField query.
       PostgreSQL implements anyone as a boolean and requires different syntax
  -->
  <mvField
    name="anyone"
    query="select ca.claimid as claimId, ca.anyone as anyone from cc_claimaccess ca where ca.permission = 10002 and ca.anyone != false"
    entityKey="claimId"
    keys="claimId"
  />

  <!-- Uncomment the following element to add digests to claim contact records but be sure to update BuildURN and
       claimcontact-search-config.xml to support digests as well. -->
  <!--
    <transformer
      name="digestTransformer"
      class="com.guidewire.solr.batchload.xform.DigestTransformer"
      algorithm="SHA"
    />
  -->

  <!-- Uncomment the following element to run a post-processor.-->
  <!--
    <postprocessor
      name="postProcessor"
      absolutePathToPostprocessorExe="${collectionConfig}/postprocess.sh"
    />
  -->
</document>
